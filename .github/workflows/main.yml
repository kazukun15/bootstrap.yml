name: Bootstrap & Build Android App

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

permissions:
  contents: write  # ソースコードを保存するために必要

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---------------------------------------------------------
      # 1. プロジェクト生成フェーズ (初回のみ実行)
      # ---------------------------------------------------------
      - name: Generate project files (if missing)
        id: generate
        shell: bash
        run: |
          # アプリのビルドファイルがなければ生成実行
          if [ -f "app/build.gradle.kts" ]; then
            echo "Project already exists. Skipping generation."
            echo "created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Generating Android project files..."
          set -euxo pipefail

          # ディレクトリ作成
          mkdir -p app/src/main/java/jp/kamijima/cyberbriefing/{car,core,net,notify,worker}
          mkdir -p app/src/main/res/values
          mkdir -p app/src/main/res/mipmap-anydpi-v26
          mkdir -p app/src/main/res/drawable
          mkdir -p app/src/main/res/drawable-v24

          # --- Root Files ---
          cat > settings.gradle.kts <<'EOF'
          pluginManagement {
              repositories {
                  google()
                  mavenCentral()
                  gradlePluginPortal()
              }
          }
          dependencyResolutionManagement {
              repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
              repositories {
                  google()
                  mavenCentral()
              }
          }
          rootProject.name = "CyberDailyBriefing"
          include(":app")
          EOF

          cat > build.gradle.kts <<'EOF'
          plugins {
              id("com.android.application") version "8.3.2" apply false
              id("org.jetbrains.kotlin.android") version "1.9.24" apply false
          }
          EOF

          cat > gradle.properties <<'EOF'
          org.gradle.jvmargs=-Xmx2g -Dfile.encoding=UTF-8
          android.useAndroidX=true
          android.nonTransitiveRClass=true
          kotlin.code.style=official
          EOF

          # --- App Build Config ---
          cat > app/build.gradle.kts <<'EOF'
          plugins {
              id("com.android.application")
              id("org.jetbrains.kotlin.android")
          }

          android {
              namespace = "jp.kamijima.cyberbriefing"
              compileSdk = 35

              defaultConfig {
                  applicationId = "jp.kamijima.cyberbriefing"
                  minSdk = 26
                  targetSdk = 35
                  versionCode = 1
                  versionName = "1.0.0"
              }

              buildFeatures { buildConfig = true }

              compileOptions {
                  sourceCompatibility = JavaVersion.VERSION_17
                  targetCompatibility = JavaVersion.VERSION_17
              }
              kotlinOptions { jvmTarget = "17" }
          }

          dependencies {
              implementation("androidx.core:core-ktx:1.13.1")
              implementation("androidx.appcompat:appcompat:1.7.0")
              implementation("com.google.android.material:material:1.12.0")
              implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.4")
              implementation("androidx.lifecycle:lifecycle-service:2.8.4")
              implementation("androidx.work:work-runtime-ktx:2.9.1")
              implementation("com.google.android.gms:play-services-location:21.3.0")
              implementation("com.squareup.okhttp3:okhttp:4.12.0")
              implementation("androidx.car.app:app:1.4.0")
          }
          EOF

          cat > app/proguard-rules.pro <<'EOF'
          # (empty)
          EOF

          # --- Manifest ---
          cat > app/src/main/AndroidManifest.xml <<'EOF'
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
              <uses-permission android:name="android.permission.INTERNET"/>
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE"/>

              <application
                  android:allowBackup="true"
                  android:label="@string/app_name"
                  android:icon="@mipmap/ic_launcher"
                  android:roundIcon="@mipmap/ic_launcher_round"
                  android:supportsRtl="true"
                  android:theme="@style/Theme.CyberDailyBriefing">

                  <activity android:name=".MainActivity" android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN"/>
                          <category android:name="android.intent.category.LAUNCHER"/>
                      </intent-filter>
                  </activity>

                  <service android:name=".car.AutoConnectionService"
                      android:exported="false"
                      android:foregroundServiceType="specialUse">
                      <property android:name="android.app.property.FOREGROUND_SERVICE_TYPE_SPECIAL_USE_DESCRIPTION"
                                android:value="Monitoring Android Auto connection state" />
                  </service>

                  <receiver android:name=".car.BootReceiver" android:exported="false">
                      <intent-filter>
                          <action android:name="android.intent.action.BOOT_COMPLETED"/>
                          <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED"/>
                      </intent-filter>
                  </receiver>
              </application>
          </manifest>
          EOF

          # --- Resources ---
          cat > app/src/main/res/values/strings.xml <<'EOF'
          <resources>
              <string name="app_name">Cyber Daily Briefing</string>
              <string name="notification_channel_monitor">Connection Monitor</string>
              <string name="monitor_service_title">Auto Monitor Active</string>
              <string name="monitor_service_desc">Waiting for vehicle connection...</string>
          </resources>
          EOF

          cat > app/src/main/res/values/themes.xml <<'EOF'
          <resources>
              <style name="Theme.CyberDailyBriefing" parent="Theme.Material3.DayNight.NoActionBar"/>
          </resources>
          EOF

          # --- Icons ---
          cat > app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml <<'EOF'
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@drawable/ic_launcher_background"/>
              <foreground android:drawable="@drawable/ic_launcher_foreground"/>
          </adaptive-icon>
          EOF
          cat > app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml <<'EOF'
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@drawable/ic_launcher_background"/>
              <foreground android:drawable="@drawable/ic_launcher_foreground"/>
          </adaptive-icon>
          EOF
          cat > app/src/main/res/drawable/ic_launcher_background.xml <<'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="108dp" android:height="108dp" android:viewportWidth="108" android:viewportHeight="108">
              <path android:fillColor="#101820" android:pathData="M0,0h108v108h-108z"/>
          </vector>
          EOF
          cat > app/src/main/res/drawable-v24/ic_launcher_foreground.xml <<'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="108dp" android:height="108dp" android:viewportWidth="108" android:viewportHeight="108">
              <path android:fillColor="#00E5FF" android:pathData="M28,54h52v4h-52z"/>
              <path android:fillColor="#00E5FF" android:pathData="M54,28h4v52h-4z"/>
              <path android:fillColor="#00E5FF" android:pathData="M24,24h8v8h-8z"/>
              <path android:fillColor="#00E5FF" android:pathData="M76,24h8v8h-8z"/>
              <path android:fillColor="#00E5FF" android:pathData="M24,76h8v8h-8z"/>
              <path android:fillColor="#00E5FF" android:pathData="M76,76h8v8h-8z"/>
          </vector>
          EOF

          # --- Kotlin Code ---
          cat > app/src/main/java/jp/kamijima/cyberbriefing/MainActivity.kt <<'EOF'
          package jp.kamijima.cyberbriefing
          import android.Manifest
          import android.content.Intent
          import android.os.Build
          import android.os.Bundle
          import androidx.activity.ComponentActivity
          import androidx.activity.result.contract.ActivityResultContracts
          import jp.kamijima.cyberbriefing.car.AutoConnectionService
          class MainActivity : ComponentActivity() {
              private val requestPermissions =
                  registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) {
                      startForegroundServiceCompat()
                      finish()
                  }
              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)
                  val perms = mutableListOf(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION)
                  if (Build.VERSION.SDK_INT >= 33) perms.add(Manifest.permission.POST_NOTIFICATIONS)
                  requestPermissions.launch(perms.toTypedArray())
              }
              private fun startForegroundServiceCompat() {
                  val intent = Intent(this, AutoConnectionService::class.java)
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { startForegroundService(intent) } else { startService(intent) }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/car/BootReceiver.kt <<'EOF'
          package jp.kamijima.cyberbriefing.car
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          class BootReceiver : BroadcastReceiver() {
              override fun onReceive(context: Context, intent: Intent) {
                  if (intent.action == Intent.ACTION_BOOT_COMPLETED || intent.action == Intent.ACTION_LOCKED_BOOT_COMPLETED) {
                      val serviceIntent = Intent(context, AutoConnectionService::class.java)
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { context.startForegroundService(serviceIntent) } else { context.startService(serviceIntent) }
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/car/AutoConnectionService.kt <<'EOF'
          package jp.kamijima.cyberbriefing.car
          import android.app.Notification
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.Service
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          import androidx.car.app.connection.CarConnection
          import androidx.core.app.NotificationCompat
          import androidx.lifecycle.LifecycleService
          import jp.kamijima.cyberbriefing.R
          import jp.kamijima.cyberbriefing.core.DailyExecutionGuard
          import jp.kamijima.cyberbriefing.core.WorkScheduler
          class AutoConnectionService : LifecycleService() {
              private var lastState: Int = CarConnection.CONNECTION_TYPE_NOT_CONNECTED
              private val CHANNEL_ID = "monitor_channel"
              private val NOTIFICATION_ID = 999
              override fun onCreate() {
                  super.onCreate()
                  startForeground(NOTIFICATION_ID, createNotification())
                  val guard = DailyExecutionGuard(this)
                  CarConnection(applicationContext).type.observe(this) { state ->
                      val prev = lastState
                      lastState = state
                      if (prev != CarConnection.CONNECTION_TYPE_PROJECTION && state == CarConnection.CONNECTION_TYPE_PROJECTION) {
                          if (guard.shouldRunToday()) { WorkScheduler.enqueueBriefing(applicationContext) }
                      }
                  }
              }
              override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                  super.onStartCommand(intent, flags, startId)
                  return Service.START_STICKY
              }
              private fun createNotification(): Notification {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                      nm.createNotificationChannel(NotificationChannel(CHANNEL_ID, getString(R.string.notification_channel_monitor), NotificationManager.IMPORTANCE_MIN))
                  }
                  return NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(getString(R.string.monitor_service_title))
                      .setContentText(getString(R.string.monitor_service_desc))
                      .setSmallIcon(R.mipmap.ic_launcher)
                      .setPriority(NotificationCompat.PRIORITY_MIN)
                      .build()
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/core/DailyExecutionGuard.kt <<'EOF'
          package jp.kamijima.cyberbriefing.core
          import android.content.Context
          import java.time.LocalDate
          class DailyExecutionGuard(context: Context) {
              private val prefs = context.getSharedPreferences("cyber_briefing", Context.MODE_PRIVATE)
              fun shouldRunToday(): Boolean {
                  val today = LocalDate.now().toString()
                  val last = prefs.getString("last_execution_date", null)
                  if (last == today) return false
                  prefs.edit().putString("last_execution_date", today).apply()
                  return true
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/core/WorkScheduler.kt <<'EOF'
          package jp.kamijima.cyberbriefing.core
          import android.content.Context
          import androidx.work.Constraints
          import androidx.work.NetworkType
          import androidx.work.OneTimeWorkRequestBuilder
          import androidx.work.WorkManager
          import jp.kamijima.cyberbriefing.worker.BriefingWorker
          object WorkScheduler {
              fun enqueueBriefing(context: Context) {
                  val constraints = Constraints.Builder().setRequiredNetworkType(NetworkType.CONNECTED).build()
                  val req = OneTimeWorkRequestBuilder<BriefingWorker>().setConstraints(constraints).addTag("daily_briefing").build()
                  WorkManager.getInstance(context).enqueue(req)
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/worker/DateUtil.kt <<'EOF'
          package jp.kamijima.cyberbriefing.worker
          import java.time.LocalDate
          object DateUtil {
              fun todayMonthDay(): Pair<String, String> {
                  val d = LocalDate.now()
                  return d.monthValue.toString().padStart(2, '0') to d.dayOfMonth.toString().padStart(2, '0')
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/worker/BriefingWorker.kt <<'EOF'
          package jp.kamijima.cyberbriefing.worker
          import android.content.Context
          import androidx.work.CoroutineWorker
          import androidx.work.WorkerParameters
          import jp.kamijima.cyberbriefing.net.LocationProvider
          import jp.kamijima.cyberbriefing.net.OnThisDayClient
          import jp.kamijima.cyberbriefing.net.WeatherClient
          import jp.kamijima.cyberbriefing.notify.BriefingComposer
          import jp.kamijima.cyberbriefing.notify.BriefingNotifier
          class BriefingWorker(appContext: Context, params: WorkerParameters) : CoroutineWorker(appContext, params) {
              override suspend fun doWork(): Result {
                  return try {
                      val loc = LocationProvider(applicationContext).getCurrentLocationOrNull()
                      val (mm, dd) = DateUtil.todayMonthDay()
                      val onThisDay = OnThisDayClient().fetchOneEventJa(mm, dd)
                      val weather = if (loc != null) WeatherClient().fetchWeatherSummary(loc.latitude, loc.longitude) else null
                      val text = BriefingComposer.composeCyber(mm, dd, onThisDay, weather)
                      BriefingNotifier(applicationContext).notifyMessage(text)
                      Result.success()
                  } catch (_: Exception) { Result.failure() }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/net/LocationProvider.kt <<'EOF'
          package jp.kamijima.cyberbriefing.net
          import android.annotation.SuppressLint
          import android.content.Context
          import com.google.android.gms.location.LocationServices
          import kotlinx.coroutines.suspendCancellableCoroutine
          import kotlin.coroutines.resume
          data class SimpleLocation(val latitude: Double, val longitude: Double)
          class LocationProvider(private val context: Context) {
              @SuppressLint("MissingPermission")
              suspend fun getCurrentLocationOrNull(): SimpleLocation? {
                  val client = LocationServices.getFusedLocationProviderClient(context)
                  return suspendCancellableCoroutine { cont ->
                      client.lastLocation.addOnSuccessListener { loc -> cont.resume(loc?.let { SimpleLocation(it.latitude, it.longitude) }) }.addOnFailureListener { cont.resume(null) }
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/net/OnThisDayClient.kt <<'EOF'
          package jp.kamijima.cyberbriefing.net
          import okhttp3.OkHttpClient
          import okhttp3.Request
          import org.json.JSONObject
          class OnThisDayClient {
              private val http = OkHttpClient()
              suspend fun fetchOneEventJa(mm: String, dd: String): String? {
                  val url = "https://api.wikimedia.org/feed/v1/wikipedia/ja/onthisday/events/$mm/$dd"
                  val req = Request.Builder().url(url).header("User-Agent", "CyberDailyBriefing/1.0").build()
                  http.newCall(req).execute().use { res ->
                      if (!res.isSuccessful) return null
                      val body = res.body?.string() ?: return null
                      val events = JSONObject(body).optJSONArray("events") ?: return null
                      var best: String? = null
                      var bestLen = Int.MAX_VALUE
                      for (i in 0 until events.length()) {
                          val text = events.getJSONObject(i).optString("text").trim()
                          if (text.isBlank()) continue
                          val len = text.length
                          if (len in 25..80 && len < bestLen) { best = text; bestLen = len }
                      }
                      if (best == null && events.length() > 0) best = events.getJSONObject(0).optString("text").trim().ifBlank { null }
                      return best
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/net/WeatherClient.kt <<'EOF'
          package jp.kamijima.cyberbriefing.net
          import okhttp3.OkHttpClient
          import okhttp3.Request
          import org.json.JSONObject
          import kotlin.math.roundToInt
          class WeatherClient {
              private val http = OkHttpClient()
              suspend fun fetchWeatherSummary(lat: Double, lon: Double): String? {
                  val url = "https://api.open-meteo.com/v1/forecast?latitude=$lat&longitude=$lon&hourly=precipitation_probability,temperature_2m&current_weather=true&timezone=Asia%2FTokyo"
                  http.newCall(Request.Builder().url(url).build()).execute().use { res ->
                      if (!res.isSuccessful) return null
                      val body = res.body?.string() ?: return null
                      val json = JSONObject(body)
                      val current = json.optJSONObject("current_weather")
                      val hourly = json.optJSONObject("hourly")
                      val probs = hourly?.optJSONArray("precipitation_probability")
                      val tempNow = current?.optDouble("temperature", Double.NaN) ?: Double.NaN
                      var maxProb = -1
                      if (probs != null) {
                          val n = minOf(6, probs.length())
                          for (i in 0 until n) { val p = probs.optInt(i, -1); if (p > maxProb) maxProb = p }
                      }
                      val tStr = if (!tempNow.isNaN()) "${tempNow.roundToInt()}度" else null
                      val probStr = when {
                          maxProb >= 70 -> "雨の確率は高いです"
                          maxProb >= 40 -> "雨の可能性があります"
                          maxProb >= 20 -> "一時的に降るかもしれません"
                          maxProb in 0..19 -> "降雨の心配はありません"
                          else -> null
                      }
                      return listOfNotNull(probStr, tStr?.let { "気温$it" }).joinToString("、").ifBlank { null }
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/notify/BriefingComposer.kt <<'EOF'
          package jp.kamijima.cyberbriefing.notify
          object BriefingComposer {
              fun composeCyber(mm: String, dd: String, onThisDay: String?, weather: String?): String {
                  val datePart = "${mm.toInt()}月${dd.toInt()}日"
                  val today = onThisDay?.let { it.replace(Regex("\\s+"), " ").trim() } ?: "過去データなし"
                  val w = weather?.let { it.replace(Regex("\\s+"), " ").trim() } ?: "気象データなし"
                  val raw = "システム通知。本日は${datePart}。${today}。現在地は、${w}。安全運転を開始してください。"
                  return if (raw.length <= 160) raw else raw.take(159) + "…"
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/notify/BriefingNotifier.kt <<'EOF'
          package jp.kamijima.cyberbriefing.notify
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.PendingIntent
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          import androidx.core.app.NotificationCompat
          import androidx.core.app.Person
          import jp.kamijima.cyberbriefing.MainActivity
          import jp.kamijima.cyberbriefing.R
          class BriefingNotifier(private val context: Context) {
              private val channelId = "daily_briefing"
              fun notifyMessage(text: String) {
                  ensureChannel()
                  val systemPerson = Person.Builder().setName("SYSTEM").build()
                  val style = NotificationCompat.MessagingStyle(systemPerson).setConversationTitle("Daily Briefing").addMessage(text, System.currentTimeMillis(), systemPerson)
                  val intent = Intent(context, MainActivity::class.java)
                  val flags = PendingIntent.FLAG_UPDATE_CURRENT or (if (Build.VERSION.SDK_INT >= 23) PendingIntent.FLAG_IMMUTABLE else 0)
                  val pi = PendingIntent.getActivity(context, 0, intent, flags)
                  val n = NotificationCompat.Builder(context, channelId).setSmallIcon(R.mipmap.ic_launcher).setContentTitle("Daily Briefing").setContentText(text).setStyle(style).setContentIntent(pi).setAutoCancel(true).setCategory(NotificationCompat.CATEGORY_MESSAGE).setPriority(NotificationCompat.PRIORITY_HIGH).build()
                  (context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager).notify(1001, n)
              }
              private fun ensureChannel() {
                  if (Build.VERSION.SDK_INT < 26) return
                  (context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager).createNotificationChannel(NotificationChannel(channelId, "Daily Briefing", NotificationManager.IMPORTANCE_DEFAULT).apply { description = "Android Auto 向けの1日1回ブリーフィング" })
              }
          }
          EOF
          
          echo "created=true" >> $GITHUB_OUTPUT

      - name: Commit generated files
        if: steps.generate.outputs.created == 'true'
        shell: bash
        run: |
          set -euxo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Bootstrap: Generate Android Project"
          git push

      # ---------------------------------------------------------
      # 2. ビルド & デプロイフェーズ (毎回実行)
      # ---------------------------------------------------------
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v3
        with:
          gradle-version: "8.6"

      - name: Build Debug APK
        run: |
          gradle --no-daemon assembleDebug

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-debug
          path: app/build/outputs/apk/debug/app-debug.apk
