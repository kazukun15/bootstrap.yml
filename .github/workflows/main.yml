name: Bootstrap & Build Android App (Chat Style)

on:
  workflow_dispatch:
  push:
    branches: [ "main" ]

permissions:
  contents: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # ---------------------------------------------------------
      # 1. プロジェクト生成フェーズ
      # ---------------------------------------------------------
      - name: Generate project files (Chat Style Notification)
        id: generate
        shell: bash
        run: |
          echo "Generating Android project files..."
          set -euxo pipefail

          # ゾンビファイル一掃（重要）
          rm -rf app/src/main/java
          rm -rf app/src/main/res

          # ディレクトリ作成
          mkdir -p app/src/main/java/jp/kamijima/cyberbriefing/{car,net,notify}
          mkdir -p app/src/main/res/values
          mkdir -p app/src/main/res/xml
          mkdir -p app/src/main/res/layout
          mkdir -p app/src/main/res/mipmap-anydpi-v26
          mkdir -p app/src/main/res/drawable
          mkdir -p app/src/main/res/drawable-v24

          # --- Root Files ---
          cat > settings.gradle.kts <<'EOF'
          pluginManagement {
              repositories {
                  google()
                  mavenCentral()
                  gradlePluginPortal()
              }
          }
          dependencyResolutionManagement {
              repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
              repositories {
                  google()
                  mavenCentral()
              }
          }
          rootProject.name = "CyberDailyBriefing"
          include(":app")
          EOF

          cat > build.gradle.kts <<'EOF'
          plugins {
              id("com.android.application") version "8.3.2" apply false
              id("org.jetbrains.kotlin.android") version "1.9.24" apply false
          }
          EOF

          cat > gradle.properties <<'EOF'
          org.gradle.jvmargs=-Xmx2g -Dfile.encoding=UTF-8
          android.useAndroidX=true
          android.nonTransitiveRClass=true
          kotlin.code.style=official
          android.suppressUnsupportedCompileSdk=35
          EOF

          # --- App Build Config ---
          cat > app/build.gradle.kts <<'EOF'
          plugins {
              id("com.android.application")
              id("org.jetbrains.kotlin.android")
          }

          android {
              namespace = "jp.kamijima.cyberbriefing"
              compileSdk = 35

              defaultConfig {
                  applicationId = "jp.kamijima.cyberbriefing"
                  minSdk = 26
                  targetSdk = 35
                  versionCode = 1
                  versionName = "1.0.0"
              }

              buildFeatures { 
                  buildConfig = true 
                  viewBinding = true
              }

              compileOptions {
                  sourceCompatibility = JavaVersion.VERSION_17
                  targetCompatibility = JavaVersion.VERSION_17
              }
              kotlinOptions { jvmTarget = "17" }
          }

          dependencies {
              implementation("androidx.core:core-ktx:1.13.1")
              implementation("androidx.appcompat:appcompat:1.7.0")
              implementation("com.google.android.material:material:1.12.0")
              implementation("androidx.constraintlayout:constraintlayout:2.1.4")
              implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.4")
              implementation("androidx.lifecycle:lifecycle-service:2.8.4")
              implementation("com.google.android.gms:play-services-location:21.3.0")
              implementation("com.squareup.okhttp3:okhttp:4.12.0")
              implementation("androidx.car.app:app:1.4.0")
          }
          EOF

          cat > app/proguard-rules.pro <<'EOF'
          # (empty)
          EOF

          # --- Manifest (Serviceに戻す + Reply Receiver) ---
          cat > app/src/main/AndroidManifest.xml <<'EOF'
          <manifest xmlns:android="http://schemas.android.com/apk/res/android">
              <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
              <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
              <uses-permission android:name="android.permission.POST_NOTIFICATIONS"/>
              <uses-permission android:name="android.permission.INTERNET"/>
              <uses-permission android:name="android.permission.RECEIVE_BOOT_COMPLETED"/>
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE"/>
              <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE"/>
              <uses-permission android:name="android.permission.VIBRATE"/>

              <application
                  android:allowBackup="true"
                  android:label="@string/app_name"
                  android:icon="@mipmap/ic_launcher"
                  android:roundIcon="@mipmap/ic_launcher_round"
                  android:supportsRtl="true"
                  android:theme="@style/Theme.CyberDailyBriefing">

                  <activity android:name=".MainActivity" android:exported="true">
                      <intent-filter>
                          <action android:name="android.intent.action.MAIN"/>
                          <category android:name="android.intent.category.LAUNCHER"/>
                      </intent-filter>
                  </activity>

                  <service android:name=".car.AutoConnectionService"
                      android:exported="false"
                      android:foregroundServiceType="specialUse">
                      <property android:name="android.app.property.FOREGROUND_SERVICE_TYPE_SPECIAL_USE_DESCRIPTION"
                                android:value="Monitoring Android Auto connection state" />
                  </service>

                  <receiver android:name=".car.BootReceiver" android:exported="false">
                      <intent-filter>
                          <action android:name="android.intent.action.BOOT_COMPLETED"/>
                          <action android:name="android.intent.action.LOCKED_BOOT_COMPLETED"/>
                      </intent-filter>
                  </receiver>
                  
                  <receiver android:name=".notify.ReplyReceiver" android:exported="false" />
              </application>
          </manifest>
          EOF

          # --- Resources ---
          cat > app/src/main/res/values/strings.xml <<'EOF'
          <resources>
              <string name="app_name">Cyber Daily Briefing</string>
              <string name="notification_channel_monitor">Connection Monitor</string>
              <string name="monitor_service_title">Auto Monitor Active</string>
              <string name="monitor_service_desc">Waiting for vehicle connection...</string>
              <string name="status_monitoring">監視中: スマホ側でこのボタンを押すと、\nAndroid Auto上にカードが出現します。</string>
              <string name="btn_test_notify">ブリーフィングを表示</string>
              <string name="reply_label">返信（実際には送信されません）</string>
          </resources>
          EOF

          cat > app/src/main/res/values/themes.xml <<'EOF'
          <resources>
              <style name="Theme.CyberDailyBriefing" parent="Theme.Material3.DayNight.NoActionBar"/>
          </resources>
          EOF

          cat > app/src/main/res/layout/activity_main.xml <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
              xmlns:app="http://schemas.android.com/apk/res-auto"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:padding="24dp"
              android:background="#101820">

              <TextView
                  android:id="@+id/tvStatus"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="@string/status_monitoring"
                  android:textColor="#00E5FF"
                  android:textSize="18sp"
                  android:textStyle="bold"
                  android:gravity="center"
                  app:layout_constraintTop_toTopOf="parent"
                  app:layout_constraintStart_toStartOf="parent"
                  app:layout_constraintEnd_toEndOf="parent"
                  app:layout_constraintBottom_toTopOf="@+id/btnTest"/>

              <Button
                  android:id="@+id/btnTest"
                  android:layout_width="wrap_content"
                  android:layout_height="wrap_content"
                  android:text="@string/btn_test_notify"
                  app:layout_constraintTop_toBottomOf="@+id/tvStatus"
                  app:layout_constraintStart_toStartOf="parent"
                  app:layout_constraintEnd_toEndOf="parent"
                  app:layout_constraintBottom_toBottomOf="parent"/>

          </androidx.constraintlayout.widget.ConstraintLayout>
          EOF

          # --- Icons ---
          cat > app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml <<'EOF'
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@drawable/ic_launcher_background"/>
              <foreground android:drawable="@drawable/ic_launcher_foreground"/>
          </adaptive-icon>
          EOF
          cat > app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml <<'EOF'
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@drawable/ic_launcher_background"/>
              <foreground android:drawable="@drawable/ic_launcher_foreground"/>
          </adaptive-icon>
          EOF
          cat > app/src/main/res/drawable/ic_launcher_background.xml <<'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="108dp" android:height="108dp" android:viewportWidth="108" android:viewportHeight="108">
              <path android:fillColor="#101820" android:pathData="M0,0h108v108h-108z"/>
          </vector>
          EOF
          cat > app/src/main/res/drawable-v24/ic_launcher_foreground.xml <<'EOF'
          <vector xmlns:android="http://schemas.android.com/apk/res/android"
              android:width="108dp" android:height="108dp" android:viewportWidth="108" android:viewportHeight="108">
              <path android:fillColor="#00E5FF" android:pathData="M28,54h52v4h-52z"/>
              <path android:fillColor="#00E5FF" android:pathData="M54,28h4v52h-4z"/>
              <path android:fillColor="#00E5FF" android:pathData="M24,24h8v8h-8z"/>
              <path android:fillColor="#00E5FF" android:pathData="M76,24h8v8h-8z"/>
              <path android:fillColor="#00E5FF" android:pathData="M24,76h8v8h-8z"/>
              <path android:fillColor="#00E5FF" android:pathData="M76,76h8v8h-8z"/>
          </vector>
          EOF

          # --- Kotlin Code ---

          # 1. Main Activity
          cat > app/src/main/java/jp/kamijima/cyberbriefing/MainActivity.kt <<'EOF'
          package jp.kamijima.cyberbriefing
          import android.Manifest
          import android.content.Intent
          import android.os.Build
          import android.os.Bundle
          import android.widget.Button
          import androidx.activity.ComponentActivity
          import androidx.activity.result.contract.ActivityResultContracts
          import androidx.lifecycle.lifecycleScope
          import jp.kamijima.cyberbriefing.car.AutoConnectionService
          import jp.kamijima.cyberbriefing.notify.BriefingNotifier
          import jp.kamijima.cyberbriefing.notify.BriefingComposer
          import jp.kamijima.cyberbriefing.net.*
          import jp.kamijima.cyberbriefing.car.DateUtil
          import kotlinx.coroutines.launch

          class MainActivity : ComponentActivity() {
              private val requestPermissions =
                  registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) {
                      startForegroundServiceCompat()
                  }

              override fun onCreate(savedInstanceState: Bundle?) {
                  super.onCreate(savedInstanceState)
                  setContentView(R.layout.activity_main)

                  findViewById<Button>(R.id.btnTest).setOnClickListener {
                      // 手動でデータを取得して通知を出す
                      lifecycleScope.launch {
                          try {
                              val loc = LocationProvider(this@MainActivity).getCurrentLocationOrNull()
                              val (mm, dd) = DateUtil.todayMonthDay()
                              val onThisDay = OnThisDayClient().fetchOneEventJa(mm, dd)
                              val weather = if (loc != null) WeatherClient().fetchWeatherSummary(loc.latitude, loc.longitude) else null
                              val text = BriefingComposer.composeCyber(mm, dd, onThisDay, weather)
                              
                              BriefingNotifier(this@MainActivity).notifyMessage(text)
                          } catch (e: Exception) {
                              e.printStackTrace()
                          }
                      }
                  }

                  val perms = mutableListOf(Manifest.permission.ACCESS_COARSE_LOCATION, Manifest.permission.ACCESS_FINE_LOCATION)
                  if (Build.VERSION.SDK_INT >= 33) perms.add(Manifest.permission.POST_NOTIFICATIONS)
                  requestPermissions.launch(perms.toTypedArray())
              }
              
              private fun startForegroundServiceCompat() {
                  val intent = Intent(this, AutoConnectionService::class.java)
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { startForegroundService(intent) } else { startService(intent) }
              }
          }
          EOF

          # 2. Boot Receiver
          cat > app/src/main/java/jp/kamijima/cyberbriefing/car/BootReceiver.kt <<'EOF'
          package jp.kamijima.cyberbriefing.car
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          class BootReceiver : BroadcastReceiver() {
              override fun onReceive(context: Context, intent: Intent) {
                  if (intent.action == Intent.ACTION_BOOT_COMPLETED || intent.action == Intent.ACTION_LOCKED_BOOT_COMPLETED) {
                      val serviceIntent = Intent(context, AutoConnectionService::class.java)
                      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) { context.startForegroundService(serviceIntent) } else { context.startService(serviceIntent) }
                  }
              }
          }
          EOF
          
          # 3. DateUtil (Moved to car package for access)
          cat > app/src/main/java/jp/kamijima/cyberbriefing/car/DateUtil.kt <<'EOF'
          package jp.kamijima.cyberbriefing.car
          import java.time.LocalDate
          object DateUtil {
              fun todayMonthDay(): Pair<String, String> {
                  val d = LocalDate.now()
                  return d.monthValue.toString().padStart(2, '0') to d.dayOfMonth.toString().padStart(2, '0')
              }
          }
          EOF

          # 4. Service (Auto Monitor)
          cat > app/src/main/java/jp/kamijima/cyberbriefing/car/AutoConnectionService.kt <<'EOF'
          package jp.kamijima.cyberbriefing.car
          import android.app.Notification
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.Service
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          import androidx.car.app.connection.CarConnection
          import androidx.core.app.NotificationCompat
          import androidx.lifecycle.LifecycleService
          import androidx.lifecycle.lifecycleScope
          import jp.kamijima.cyberbriefing.R
          import jp.kamijima.cyberbriefing.net.*
          import jp.kamijima.cyberbriefing.notify.*
          import kotlinx.coroutines.launch

          class AutoConnectionService : LifecycleService() {
              private var lastState: Int = CarConnection.CONNECTION_TYPE_NOT_CONNECTED
              private val CHANNEL_ID = "monitor_channel"
              private val NOTIFICATION_ID = 999
              private var lastExecDate: String? = null

              override fun onCreate() {
                  super.onCreate()
                  startForeground(NOTIFICATION_ID, createNotification())
                  
                  CarConnection(applicationContext).type.observe(this) { state ->
                      val prev = lastState
                      lastState = state
                      if (prev != CarConnection.CONNECTION_TYPE_PROJECTION && state == CarConnection.CONNECTION_TYPE_PROJECTION) {
                          // 接続時に実行（1日1回制限付き）
                          val today = java.time.LocalDate.now().toString()
                          if (lastExecDate != today) {
                              lastExecDate = today
                              performBriefing()
                          }
                      }
                  }
              }
              
              private fun performBriefing() {
                  lifecycleScope.launch {
                      try {
                          val loc = LocationProvider(this@AutoConnectionService).getCurrentLocationOrNull()
                          val (mm, dd) = DateUtil.todayMonthDay()
                          val onThisDay = OnThisDayClient().fetchOneEventJa(mm, dd)
                          val weather = if (loc != null) WeatherClient().fetchWeatherSummary(loc.latitude, loc.longitude) else null
                          val text = BriefingComposer.composeCyber(mm, dd, onThisDay, weather)
                          BriefingNotifier(this@AutoConnectionService).notifyMessage(text)
                      } catch (_: Exception) {}
                  }
              }

              override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
                  super.onStartCommand(intent, flags, startId)
                  return Service.START_STICKY
              }
              private fun createNotification(): Notification {
                  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
                      val nm = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
                      nm.createNotificationChannel(NotificationChannel(CHANNEL_ID, getString(R.string.notification_channel_monitor), NotificationManager.IMPORTANCE_MIN))
                  }
                  return NotificationCompat.Builder(this, CHANNEL_ID)
                      .setContentTitle(getString(R.string.monitor_service_title))
                      .setContentText(getString(R.string.monitor_service_desc))
                      .setSmallIcon(R.mipmap.ic_launcher)
                      .setPriority(NotificationCompat.PRIORITY_MIN)
                      .build()
              }
          }
          EOF

          # 5. Notifier (SUPERCHARGED with REPLY)
          cat > app/src/main/java/jp/kamijima/cyberbriefing/notify/BriefingNotifier.kt <<'EOF'
          package jp.kamijima.cyberbriefing.notify
          import android.app.NotificationChannel
          import android.app.NotificationManager
          import android.app.PendingIntent
          import android.content.Context
          import android.content.Intent
          import android.os.Build
          import androidx.core.app.NotificationCompat
          import androidx.core.app.Person
          import androidx.core.app.RemoteInput
          import jp.kamijima.cyberbriefing.MainActivity
          import jp.kamijima.cyberbriefing.R

          class BriefingNotifier(private val context: Context) {
              private val channelId = "daily_briefing_chat_v3"
              
              fun notifyMessage(text: String) {
                  ensureChannel()
                  
                  // 1. Person定義（これが送信者名になる）
                  val sender = Person.Builder()
                      .setName("Cyber Briefing") // カードの一番上に出る名前
                      .setKey("cyber_system")
                      .setBot(true)
                      .build()
                  
                  // 2. 返信アクション（これがAutoに「会話」だと認識させる鍵）
                  val remoteInput = RemoteInput.Builder("key_reply")
                      .setLabel("返信")
                      .build()
                  
                  val replyIntent = Intent(context, ReplyReceiver::class.java)
                  val replyPendingIntent = PendingIntent.getBroadcast(
                      context, 0, replyIntent,
                      PendingIntent.FLAG_MUTABLE or PendingIntent.FLAG_UPDATE_CURRENT
                  )
                  
                  val replyAction = NotificationCompat.Action.Builder(
                      android.R.drawable.ic_menu_send,
                      "返信",
                      replyPendingIntent
                  ).addRemoteInput(remoteInput).build()

                  // 3. メッセージスタイルの構築
                  // 現在時刻のメッセージとして追加
                  val style = NotificationCompat.MessagingStyle(sender)
                      .addMessage(text, System.currentTimeMillis(), sender)
                  
                  // 4. 通知発行
                  val n = NotificationCompat.Builder(context, channelId)
                      .setSmallIcon(R.mipmap.ic_launcher)
                      .setStyle(style)
                      .addAction(replyAction) // 重要！
                      .setAutoCancel(true)
                      .setCategory(NotificationCompat.CATEGORY_MESSAGE)
                      .setPriority(NotificationCompat.PRIORITY_MAX) 
                      .setDefaults(NotificationCompat.DEFAULT_ALL)
                      .build()
                      
                  (context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager).notify(1001, n)
              }
              
              private fun ensureChannel() {
                  if (Build.VERSION.SDK_INT < 26) return
                  // 重要度HIGHで音とバイブレーションを有効化
                  val channel = NotificationChannel(channelId, "Briefing Chat", NotificationManager.IMPORTANCE_HIGH).apply {
                      description = "Chats appearing on dashboard"
                      enableVibration(true)
                  }
                  (context.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager).createNotificationChannel(channel)
              }
          }
          EOF
          
          # 6. Dummy Reply Receiver
          cat > app/src/main/java/jp/kamijima/cyberbriefing/notify/ReplyReceiver.kt <<'EOF'
          package jp.kamijima.cyberbriefing.notify
          import android.content.BroadcastReceiver
          import android.content.Context
          import android.content.Intent
          import androidx.core.app.NotificationManagerCompat
          
          class ReplyReceiver : BroadcastReceiver() {
              override fun onReceive(context: Context, intent: Intent) {
                  // 返信ボタンが押されたら、通知を既読（削除）にする
                  // これで「話し終わったら消える」挙動になる
                  NotificationManagerCompat.from(context).cancel(1001)
              }
          }
          EOF

          # Utilities (Unchanged)
          cat > app/src/main/java/jp/kamijima/cyberbriefing/net/LocationProvider.kt <<'EOF'
          package jp.kamijima.cyberbriefing.net
          import android.annotation.SuppressLint
          import android.content.Context
          import com.google.android.gms.location.LocationServices
          import kotlinx.coroutines.suspendCancellableCoroutine
          import kotlin.coroutines.resume
          data class SimpleLocation(val latitude: Double, val longitude: Double)
          class LocationProvider(private val context: Context) {
              @SuppressLint("MissingPermission")
              suspend fun getCurrentLocationOrNull(): SimpleLocation? {
                  val client = LocationServices.getFusedLocationProviderClient(context)
                  return suspendCancellableCoroutine { cont ->
                      client.lastLocation.addOnSuccessListener { loc -> cont.resume(loc?.let { SimpleLocation(it.latitude, it.longitude) }) }.addOnFailureListener { cont.resume(null) }
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/net/OnThisDayClient.kt <<'EOF'
          package jp.kamijima.cyberbriefing.net
          import okhttp3.OkHttpClient
          import okhttp3.Request
          import org.json.JSONObject
          class OnThisDayClient {
              private val http = OkHttpClient()
              suspend fun fetchOneEventJa(mm: String, dd: String): String? {
                  val url = "https://api.wikimedia.org/feed/v1/wikipedia/ja/onthisday/events/$mm/$dd"
                  val req = Request.Builder().url(url).header("User-Agent", "CyberDailyBriefing/1.0").build()
                  http.newCall(req).execute().use { res ->
                      if (!res.isSuccessful) return null
                      val body = res.body?.string() ?: return null
                      val events = JSONObject(body).optJSONArray("events") ?: return null
                      var best: String? = null
                      var bestLen = Int.MAX_VALUE
                      for (i in 0 until events.length()) {
                          val text = events.getJSONObject(i).optString("text").trim()
                          if (text.isBlank()) continue
                          val len = text.length
                          if (len in 25..80 && len < bestLen) { best = text; bestLen = len }
                      }
                      if (best == null && events.length() > 0) best = events.getJSONObject(0).optString("text").trim().ifBlank { null }
                      return best
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/net/WeatherClient.kt <<'EOF'
          package jp.kamijima.cyberbriefing.net
          import okhttp3.OkHttpClient
          import okhttp3.Request
          import org.json.JSONObject
          import kotlin.math.roundToInt
          class WeatherClient {
              private val http = OkHttpClient()
              suspend fun fetchWeatherSummary(lat: Double, lon: Double): String? {
                  val url = "https://api.open-meteo.com/v1/forecast?latitude=$lat&longitude=$lon&hourly=precipitation_probability,temperature_2m&current_weather=true&timezone=Asia%2FTokyo"
                  http.newCall(Request.Builder().url(url).build()).execute().use { res ->
                      if (!res.isSuccessful) return null
                      val body = res.body?.string() ?: return null
                      val json = JSONObject(body)
                      val current = json.optJSONObject("current_weather")
                      val hourly = json.optJSONObject("hourly")
                      val probs = hourly?.optJSONArray("precipitation_probability")
                      val tempNow = current?.optDouble("temperature", Double.NaN) ?: Double.NaN
                      var maxProb = -1
                      if (probs != null) {
                          val n = minOf(6, probs.length())
                          for (i in 0 until n) { val p = probs.optInt(i, -1); if (p > maxProb) maxProb = p }
                      }
                      val tStr = if (!tempNow.isNaN()) "${tempNow.roundToInt()}度" else null
                      val probStr = when {
                          maxProb >= 70 -> "雨の確率は高いです"
                          maxProb >= 40 -> "雨の可能性があります"
                          maxProb >= 20 -> "一時的に降るかもしれません"
                          maxProb in 0..19 -> "降雨の心配はありません"
                          else -> null
                      }
                      return listOfNotNull(probStr, tStr?.let { "気温$it" }).joinToString("、").ifBlank { null }
                  }
              }
          }
          EOF

          cat > app/src/main/java/jp/kamijima/cyberbriefing/notify/BriefingComposer.kt <<'EOF'
          package jp.kamijima.cyberbriefing.notify
          object BriefingComposer {
              fun composeCyber(mm: String, dd: String, onThisDay: String?, weather: String?): String {
                  val datePart = "${mm.toInt()}月${dd.toInt()}日"
                  val today = onThisDay?.let { it.replace(Regex("\\s+"), " ").trim() } ?: "過去データなし"
                  val w = weather?.let { it.replace(Regex("\\s+"), " ").trim() } ?: "気象データなし"
                  return "システム通知。本日は${datePart}。${today}。現在地は、${w}。安全運転を開始してください。"
              }
          }
          EOF
          
          echo "created=true" >> $GITHUB_OUTPUT

      - name: Commit generated files
        if: steps.generate.outputs.created == 'true'
        shell: bash
        run: |
          set -euxo pipefail
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          git commit -m "Bootstrap: Implement Chat Style Notification"
          git push

      # ---------------------------------------------------------
      # 2. ビルド & デプロイフェーズ
      # ---------------------------------------------------------
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: "temurin"
          java-version: "17"

      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v3
        with:
          gradle-version: "8.6"

      - name: Build Debug APK
        run: |
          gradle --no-daemon assembleDebug

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: CyberDailyBriefing_ChatStyle.apk
          path: app/build/outputs/apk/debug/app-debug.apk
